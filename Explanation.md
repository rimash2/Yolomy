## Dockerizing the Project
## Base Image
The base image i used is node:alpine . The main reason i used this as the base image is due to its small relative size hence less memory, better performance, security and maintainability. It offers a strong base for customization. Itâ€™s built with simplicity in mind.

## Dockerfile Directives
## FROM node:alpine
The FROM directive specifies the base image that the Dockerfile will use to build a new image. In this case, the node:18-alpine3.16 image will be used as the base image.

## WORKDIR /app/client
The WORKDIR directive sets the working directory for the commands that follow it in the Dockerfile. In this case, the working directory will be set to /app.

## COPY package.json /app/
## COPY package-lock.json /app/
The COPY directive is used to copy files from the host machine to the working directory in the image. In this case, the package*.json files will be copied to the /app directory.

## RUN npm install
The RUN directive is used to execute a command in the context of the image. In this case, the npm install command will be run to install the dependencies specified in the package*.json files.

## COPY . /app/
The final COPY directive copies all files in the current directory to the /app directory in the image.

## CMD [ "npm", "start" ]
The CMD directive specifies the default command that will be executed when the image is run as a container. In this case, the npm start command will be run. This is typically used to start the application that was installed and built using the previous commands in the Dockerfile.

## Docker Compose Networking
For the client side I allocated port 3000 for both the docker cntainer and localhost to run the application on the localhost. The YAML
ports: - 3000:3000

And port 5000 for the backend:
ports: - 5000:5000

## Docker Compose Volume
Volumes are the preferred, and extensively used, mechanisms for persisting data generated by Docker containers. Docker volumes basically create a link between one of the local folders on the system and the folder on the docker container. These folders have data replication so that even if a container gets restarted/deleted at some point in time, you will still have access to the data that the container generated. I defined a volume for storing data from the mongodb database and named it mongo_db. Below is YAML i used in defining the docker compose volume:
volumes:
mongo_db: {}

And the YAML for storing the data of the mongodb microservice :
volumes:
- mongo_db:/data/db

## Git Workflow
Git clone the repository.

Commit the changes.

Pushed to github main branch of forked repository.

## Running the application
To run the YOLO application using Docker Compose, follow these instructions: - Fork the repository at https://github.com/rimash2/Yolomy - Clone the repository to your local machine using the command git clone https://github.com/<Your Username>>/Yolomy.git - Change into the yolomy directory using the command cd yolomy - Build the Docker images and start the containers by running docker-compose up --build - The backend will be running on port 5000 and the frontend will be running on port 3000. You can access the application in your web browser at http://localhost:3000
